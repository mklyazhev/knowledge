### **Виды join'ов**

**inner** - внутреннее соединение. В результате остаются только те строки, для которых нашлось соответствие в обоих таблицах.

**full** - полное внешнее соединение. Если для какой-либо из таблиц не нашлось строки в другой таблице, то строка все равно попадает в результат, а значения столбцов другой таблицы равны null.

**left** - левое внешнее соединение. Работает как JOIN, но если для строки таблицы, находящейся по левую сторону ключевого слова LEFT JOIN, не нашлось ни одной строки в таблице, находящейся по правую сторону LEFT JOIN, то строка все равно добавляется в результат, а значения столбцов правой таблицы равны null.

**right** - правое внешнее соединение. Работает как JOIN, но если для строки таблицы, находящейся по правую сторону ключевого слова RIGHT JOIN, не нашлось ни одной строки в таблице, находящейся по левую сторону RIGHT JOIN, то строка все равно добавляется в результат, а значения столбцов левой таблицы равны null.

**cross** - перекрестное (или декартово) произведение. Каждая строка одной таблицы соединяется с каждой строкой второй таблицы, давая тем самым в результате все возможные сочетания строк двух таблиц. Не нужно писать условие.

**natural** - естественного объединение. Создаёт неявное объединение на основе одинаковых имён столбцов в объединяемых таблицах. Естественное объединение может быть внутренним, левым или правым. Не нужно писать условие.
### **group by**

Оператор **group by** определяет, как строки будут группироваться. Уменьшает количество строк в выборке до количества групп. Если в выражении **select** производится выборка по одному или нескольким столбцам и также используются агрегатные функции, то необходимо использовать выражение **group by**.
### **having**

Оператор **having** определяет, какие группы будут включены в выходной результат, то есть выполняет фильтрацию групп.
### **where**

Оператор **where** позволяет задавать дополнительные условия фильтрации для выборки.
### **В чем разница между where и having**

**where** происходит до агрегации (т.е. фильтрует каждый отдельный ряд), а **having** после. Применение **having** во многом аналогично применению **where**. Только если **where** применяется к фильтрации строк, то **having** используется для фильтрации групп.
### order by

Сортирует выборку по условию.
### **limit**

Выводит первые N строк.
В T-SQL нет **limit**, там используется **top**.
### offset

Смещение результатов выборки на N строк. Например, если нужно вывести выборку, пропустив первые N строк.
### **Оконные функции**

Функции, которые применяются к наборам строк внутри выборки, начинаются с оператора **over()**, настраиваются с помощью операторов **partition by**, **order by,** **rows**. Не уменьшают количество строк в выборке, в отличие от **group by**.

При обычном запросе, все множество строк обрабатывается как бы единым «цельным куском», для которого считаются агрегаты. А при использовании оконных функций, запрос делится на части (окна) и уже для каждой из отдельных частей считаются свои агрегаты.
### **Подзапросы**

Это **select-запрос**, вложенный в другой запрос или подзапрос. Подзапросами пользуются, когда нужно использовать результат выполнения одного запроса в другом запросе.
Подзапрос всегда заключён в круглые скобки и обычно выполняется перед основным запросом.
### **Порядок выполнения команд**

Сначала выполняется команда **выборки** таблиц, их **объединения** и возможные **подзапросы** под командой **from.**

Далее выполняются условия фильтрации **where**, группировки **group by** и возможная фильтрация c **having.**

Только потом применяется команда выборки столбцов **select** и расчет оконных функций под выборкой.

После этого идет условие сортировки **order by**, где тоже можно указать столбец расчета оконной функции для сортировки.  
Здесь важно уточнить, что партиции или окна оконных функций создаются после разделения таблицы на группы с помощью команды **group by**, если эта команда используется в запросе.
### **Хранимые процедуры**

Хранимые процедуры представляют набор инструкций, которые выполняются как единое целое. Тем самым хранимые процедуры позволяют упростить комплексные операции и вынести их в единый объект.

Могут принимать и не принимать параметры, могут изменять состояние БД, ничего не возвращают. Обычно в процедурах содержится какая-либо бизнес-логика.
### **Триггеры**

Часть процедурного кода, как и хранимая процедура, но который выполняется только при наступлении определенного события. Например, при удалении записи из таблицы, вставке или обновлении.
### **Функции**

Тоже набор инструкций. В функций можно вынести какие-либо повторяющиеся действия.

Обязательно есть входные параметры параметры, обязательно возвращают значение, не могут изменять состояние БД.

Могут возвращать значение, таблицу, либо null.
### **Представления**

**Представления** или **views** представляют виртуальные таблицы. Но в отличии от обычных стандартных таблиц в базе данных представления содержат запросы, которые динамически извлекают используемые данные.

Они упрощают комплексные SQL-операции. Они защищают данные, так как представления могут дать доступ к части таблицы, а не ко всей таблице. Представления также позволяют возвращать отформатированные значения из таблиц в нужной и удобной форме.

Грубо говоря - это заскриптованный **select** запрос.
### Курсор

Это особый временный объект SQL, предназначенный для использования в запросах и хранимых процедурах. С его помощью можно в цикле пройти по результирующему набору строк запроса, по отдельности считывая и обрабатывая каждую его строку.
### Индексы

Это особые таблицы, используемые поисковыми системами для поиска данных.

Благодаря индексу процесс поиска данных сокращается за счет их упорядочивания как физического, так и логического. Таким образом, он выглядит как набор ссылок на данные, которые упорядочены по выбранному столбцу таблицы. Такой столбец называется индексированным.

Но не всегда индекс помогает ускорить поиск информации. Для таблиц небольших размеров обычный перебор данных может оказаться намного эффективнее выборки данных по индексам.

Индексы имеют и недостатки:
- индекс хранится на диске и требуется много места на дисковом пространстве и в оперативной памяти. Чем длиннее ключ, тем большего размера индекс и место для его хранения;
- замедляется производительность системы (медленнее выполняются операции вставок, обновления, либо удаления записей). Каждая операция с таблицей происходит и со всеми ее индексами.
### Структура индексов

Все индексы имеют одинаковую структуру. Они состоят из:
- наборов страниц;
- узлов, имеющих древовидную структуру, иерархическую по природе.

Все они хранятся в виде сбалансированных B-деревьев (B-tree). Начало такого дерева расположено в корневом узле (находящимся на вершине иерархии) и по сути является «входной дверью». Этот узел имеет одну страницу, в которой содержатся указатели на ключи последующих уровней. В нижней части иерархии расположены листья дерева (являющиеся конечными узлами). Длины веток одинаковы. В таком дереве сбалансирована каждая ветка. Благодаря внутреннему механизму при любых изменениях в таблице дерево снова становится сбалансированным.

При формировании запроса к индексированному столбцу подсистема начинает процесс поиска с верхнего узла к нижним, проходя промежуточные и обрабатывая их. На каждом уровне располагается все более развернутая информация о запрашиваемых данных. Как только достигается нижний уровень листьев (leaf level) поиск прекращается, т.к. подсистема запросов находит необходимое значение.
### **Типы индексов**

- **Кластерный (Clustered)**
  Основная его задача — сохранение табличных данных в виде, отсортированном по значению первичного ключа. Таблице или представлению может быть присущ лишь единственный кластеризованный индекс, потому что табличные данные могут отсортировываться в едином возможном порядке – либо возрастания, либо убывания. Кластеризованный индекс хранит реальные строки данных в листьях индекса.

- **Некластерный (Nonclustered)**  
  Некластеризованными называют такие индексы, которые содержат:  
    - значения ключевых столбцов, по которым они определены;  
    - указатели на строки в таблице, содержащие реальные данные (значения ключа).  
  Можно создать больше одного некластерного индекса (до 999).

Сущестуют также специальные типы индексов, которые могут быть как кластерными, так и некластерными:

- **Фильтруемый (Filtered)** - оптимизированный некластерный индекс, в котором задействован предикат фильтра для индексации части строк в таблице.

- **Составной**:
    - может включать более одного (до 16) столбцов, выступающих ключевыми значениями;  
    - ограничивается общей длиной (не превышающей 900 байт);  
    - содержит поля, которые принадлежат единой таблице.
  Простые индексы, в отличие от составных, создаются лишь по единственному столбцу.  Отличным примером может служить телефонный справочник. Он сформирован по фамилии и имени, т.к. много людей имеют одинаковую фамилию. Следовательно, логично будет создать индекс одновременно и по фамилии, и по имени.
 
- **Уникальнный (Unique)** - индекс, обеспечивающий уникальное значение всех строк по определенному ключу и гарантирующий, что в ключе индекса не будет значений одинаковых, повторяющихся. Для составного ключа понятие уникальности касается всех index columns, но не распространяется на каждый столбец в отдельности. 
  Если в таблице формируется уникальный индекс одновременно по ряду столбцов, это означает, что абсолютно каждая вариация значений в ключе будет уникальной.
  
- **Колоночный (Columnstore)** - индекс, в котором данные хранятся в столбцах.
  Колоночные индексы наиболее целесообразно применять для крупных хранилищ, т.к. они помогут:
    - производительность запросов увеличить в несколько раз;
    - размеры данных уменьшить (благодаря их сжатию).  
  Суть columnstore в том, что хранение данных осуществляется не в строках, но в колонках. Т.е. на одну страницу (всем известные 8 Кб) сервер записывает данные только одного поля. И так с каждым полем в таблице по очереди. Необходимо это для того, чтобы не приходилось считывать лишнюю информацию. Давайте представим таблицу с 10 полями и запрос, у которого в операторе select указано только одно поле. Если бы это была обычная таблица сохранённая в row-based формате, сервер был бы вынужден считывать все 10 полей, но при этом возвращать только одно. Получилось бы, что сервер считал в 9 раз больше информации, чем было необходимо. Columnstore полностью решает эту проблему, т.к. формат хранения позволяет считывать только одно заказанное поле. Все это происходит, потому что единица хранения в РСУБД — это страница. Т.е. сервер всегда записывает и считывает, как минимум одну страницу. Вопрос только в том, сколько полей присутствует на ней.
 
- **Пространственный (Spatial)** - индекс, позволяющий индексировать столбцы с пространственными данными (представленные в типах Geography или Geometry). Spatial index позволяет наилучшим образом использовать определенные операции запросов относительно пространственных столбцов и может создаваться только для них.

- **Полнотекстовые (Full-text)** - индекс, применяющийся для повышения эффективности поиска определенных слов в строках, где данные представлены в символах.

- **Покрывающий (Covering)** - индекс, позволяющий на конкретный запрос получать запрашиваемую информацию в полном объеме с листьев индекса, не обращаясь к записям таблицы. А значит, в Covering index хранится достаточный объем данных для полноценного ответа на запрос. Потому нет необходимости обращаться к таблице.

- **XML-индекс** – специфический тип индекса, предназначенный для работы с данными в столбцах таблицы, представленными в формате xml. Он делает более эффективной обработку поисковых запросов к ним.
### **Кучи**

Как только таблица создана и в ней еще нет индексов, она выглядит как **куча данных (Heap)**. В ней все записи хранятся хаотично, без определенного порядка. Потому их и называют «кучами».

Если в таблице необходимо найти определенные данные, СУБД просканирует ее. Пока в таблице не заданы индексы, поддерживающие ограничения (unique constraint, unique index или primary key), сервер прочитает все табличные записи (с первой до последней) и выберет те, которые удовлетворяют условиям поиска.
### Партиции

**Партиционирование (partitioning)** — это разбиение больших таблиц на логические части по выбранным критериям. Используется в целях повышения управляемости, производительности и доступности для больших баз данных, т.к. позволяет оперировать с куском таблицы, а не всей сразу.

Больше 1000 партиций на таблицу - это плохо. Партиции для таблиц, где меньше 10 млн строк не нужны.
### Ограничения

В SQL обычно используются следующие ограничения:
- **not null** - гарантирует, что столбец не может иметь нулевое значение.
- **unique** - гарантирует, что все значения в столбце будут разными.
- **primary key** - комбинация not null и unique. Уникально идентифицирует каждую строку в таблице.
- **foreign key** - однозначно идентифицирует строку/запись в другой таблице.
- **check** - гарантирует, что все значения в столбце удовлетворяют определенному условию.
- **default** - задает значение по-умолчанию для столбца, если значение не указано.
### Ключи

- **Первичный ключ (Primary key)** - ключ, который устанавливается для однозначной идентификации той или иной записи в таблице. Значения первичного ключа должны быть всегда уникальны, а так же не содержать значений null.

- **Внешний ключ (Foreign key)** - позволяет установить связи между таблицами. Внешний ключ устанавливается для столбцов из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы. 
  Нужен для обеспечения ссылочной целостности.
### **Транзакции**

**Транзакция** — это набор операций по работе с базой данных (БД), объединенных в одну атомарную пачку. Т.е. соблюдается принцип «всё, или ничего». После сохранения транзакции или выполнены все запросы, которые разработчик упаковал в одну транзакцию, или ни один.
### **Языки DDL/DML/DCL/TCL**

- **Data Definition Language (DDL)** – это группа операторов определения данных. Другими словами, с помощью операторов, входящих в эту группы, мы определяем структуру базы данных и работаем с объектами этой базы, т.е. создаем, изменяем и удаляем их (**create, alter, drop, truncate**).

- **Data Manipulation Language (DML)** – это группа операторов для манипуляции данными. С помощью этих операторов мы можем добавлять, изменять, удалять и выгружать данные из базы, т.е. манипулировать ими (**select, update, insert, delete**).

- **Data Control Language (DCL)** – группа операторов определения доступа к данным. Иными словами, это операторы для управления разрешениями, с помощью них мы можем разрешать или запрещать выполнение определенных операций над объектами базы данных (**grant, revoke, deny**).

- **Transaction Control Language (TCL)** – группа операторов для управления транзакциями. Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, при этом в базе данных все внесенные изменения фиксируются на постоянной основе или отменяются, т.е. все изменения, внесенные любой командой, входящей в транзакцию, будут отменены (**begin transaction, commit transaction, rollback transaction ,save transaction**).
### Как читать план запроса

План выполняется справа налево, сверху вниз.